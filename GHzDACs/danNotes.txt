Server - Run Sequence
    devs = [devices in daisy chain order]
    runners = [runner(dev) for dev in devs]
        defaults for DAC: mem = None
                          sram = None
                          startDelay = 0
        defaults for ADC: None, errors raised if things not set
        DacRunner(dev, reps, startDelay, mem, sram):
            self._fixDualBlockSram()
                #At this point SRAM exists as block0, block1, delay
                #Set the sram start and end addresses as shown in GHzDAC .doc
                self.mem = fixSRAMaddresses(self.mem, self.sram, self.dev)
                self.sram = <make a big string out of the two blocks>
            if self.pageable():
            self.nPackets = calculate expected number of data packets
            self.memTime = time in seconds of one memory sequence, assumes SRAM is 12us
            self.seqTime = TIMEOUT_FACTOR * (memTime * reps) + 1
        AdcRunner(dev, reps, runMode, startDelay, filter, channels)
            self.runMode = string representing run mode "demodulate" or "average"
            self.mode = number indicating run mode for register packet
            self.seqTime = TIMEOUT_FACTOR * (26us * reps) + 1
    timingOrder = c['timing_order'], some logic here
    while 1:
        try:
            ans = yield bg.run(runners, reps, setupReqs, set(setupState), c['master_sync'], getTimingData, timingOrder)
        except TimeoutError, err:
            log err to file and stdout
            attempt += 1
        if attempt >= retries:
            raise

Board group - run
    if not all runners pageable: get both page locks
    pkts = self.makePackets(runners, page, reps, timingOrder, sync)
    loadPkts, boardSetupPkts, runPkts, collectPkts, readPkts = pkts
        loadpkts - load memory and SRAM for DAC. None for ADC.
            Add delays before all SRAM calls on master board only.
            Recompute memTime and seqTime
        setupPkts - 
            DAC: nothing
            ADC: setupPkts = [runner.setupPkt()]
        runPkts - get list of (device, registers). Master and idle boards determined by simple logic.
            p = self.server.packet(context = self.ctxt)
            p.wait_for_trigger(0, key='nTriggers')
            p.destination_mac(dev.MAC).write(regs)
            #Note that here we're talking to the de server through the master context every time
            #That's why we have to switch destination MAC for each write command.
            #This is done so that we can set the number of triggers to wait for before actually sending
            #the run packets.
        collectPkts - Wait for packets to come back. Each collect command sends one trigger to the master context.
        readPkts - readout out specified number of packets
        #Note that all packets are sent in each board's individual direct ethernet context, EXCEPT for
        #the run packets. Those are sent by the master context.
    setupPkts.extend(all the boardSetPkts)
    setupState.update(state for state in boardSetupState)
    Add setup packets and setup state to what was fed into run
    try:
        yield acquire pipe semaphore
        try:
            yield acquire pageLock
            loadDone = self.sendAll(loadPkts, 'Load')
            runNow = self.runLock.acquire()
            try:
                yield loadDone #Wait for load to finish
                yield runNow   #Wait for run lock
                waitPkt, runPkt, bothPkt = runPkts
                waitPkt['nTriggers'] = self.prevTriggers
                bothPkt['nTriggers'] = self.prevTriggers
                self.prevTriggers = len(runners)
                if need setup:
                    r = yield waitPkt().send()
                    try:
                        yield send setup packets
                        self.setupState = setupState
                    except Exception:
                        clear setup state
                        raise
                    yield runPkt.send()
                else:
                    r = yield bothPkt.send()
                self.runWaitTimes = r['nTriggers']
                yield self.readlock.acquire()
                collectAll = send collect packets
            finally:
                self.runLock.release()
            retults = yield collectAll
        finally:
            pageLock.release()
        if not all (success for success,result in results):
            print some errors
            yield self.recoverFromTimeout(runners,results)
            self.readLock.release()
        boardOrder = [runner.dev.devName for runner in runners]
        readAll = self.sendAll(readPkts,'Read',boardOrder)
        self.readLock.release()
        results = yield readAll
        if getTimingData:
            answers = extract data
            returnValue(answers)
    finally:
        self.pipeSemaphore.release()