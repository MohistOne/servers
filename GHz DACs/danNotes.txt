Server - Run Sequence
 devs = devices in daisychain order
 runners = [runnser(dev) for dev in devs]
 while 1:
  try:
   ans = yield bg.run(runners, reps, setupReqs, set(setupState), c['master_sync'], getTimingData, timingOrder)
  except TimeoutError, err:
   log err to file and stdout
   attempt += 1
  if attempt >= retries:
   raise

Board group - run
 make packets:
  loadpkts - load memory and SRAM. Fixes memory for master start delay, SRAM paging, etc.
  setupPkts - external (nonpipelined) setup, eg. microwave source settings
  runPkts - get list of (device, registers). Master and idle boards determined by simple logic.
   p = self.server.packet(context = self.ctxt)
   p.wait_for_trigger(0, key='nTriggers')
   p.destination_mac(dev.MAC).write(regs)
   #Note that here we're talking to the de server through the master context every time
   #That's why we have to switch destination MAC for each write command.
   #This is done so that we can set the number of triggers to wait for before actually sending
   #the run packets.
  collectPkts - Wait for packets to come back. Each collect command sends one trigger to
                the master context.
  readPkts - readout out specified number of packets
  #Note that all packets are sent in each board's individual direct ethernet context, EXCEPT for
  #the run packets. Those are sent by the master context.